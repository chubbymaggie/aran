exports.compile = require('./compile');
exports.client = "\n(function () {\n\n  var g = (function () { return this } ());\n  if (!g) {\n    if (typeof global !== \"undefined\")\n      g = global;\n    else if (typeof window !== \"undefined\")\n      g = window;\n    else\n      throw new Error(\"Aran could not find the global object...\");\n  }\n\n  var aran = g.aran = {};\n\n  aran.apply = function (f, t, xs) { return f.apply(t, xs) };\n  aran.apply = (g.Reflect && g.Reflect.apply) || aran.apply;\n\n  aran.enumerate = function (o) {\n    var ks = [];\n    for (var k in o)\n      ks[ks.length] = k;\n    return ks;\n  };\n  aran.enumerate = (g.Reflect && g.Reflect.enumerate) || aran.enumerate;\n\n  aran.eval = eval;\n\n  var defineProperties = Object.defineProperties;\n\n  aran.object = function (xs) {\n    var ps = {};\n    for (var i=0; i<xs.length; i+=3) {\n      if (!ps[xs[i]])\n        ps[xs[i]] = {enumerable:true, configurable:true};\n      if (xs[i+1] === \"init\") {\n        delete ps[xs[i]].get;\n        delete ps[xs[i]].set;\n        ps[xs[i]].writable = true;\n        ps[xs[i]].value = xs[i+2]\n      } else {\n        delete ps[xs[i]].writable\n        delete ps[xs[i]].value\n        ps[xs[i]][xs[i+1]] = xs[i+2]\n      }\n    }\n    return defineProperties({}, ps);\n  };\n\n} ());\n\n(function () {\n\n  function strict (ast) {\n    return ast.type === \"ExpressionStatement\"\n      && ast.expression.type === \"Literal\"\n      && ast.expression.value === \"use strict\";\n  }\n\n  aran.childs = {};\n\n  aran.childs.Program = function (x) {\n    var xs = [];\n    for (var i=0; i<x.body.length; i++)\n      xs[xs.length] = x.body[i];\n    return xs;\n  };\n\n  aran.childs.EmptyStatement = function (x) { return [] };\n\n  aran.childs.BlockStatement = function (x) {\n    var xs = [];\n    for (var i=0; i<x.body.length; i++)\n      xs[xs.length] = x.body[i];\n    return xs;\n  };\n\n  aran.childs.ExpressionStatement = function (x) { return [x.expression] };\n\n  aran.childs.IfStatement = function (x) { return x.alternate ? [x.test, x.consequent, x.alternate] : [x.test, x.consequent] };\n\n  aran.childs.LabeledStatement = function (x) { return [] };\n\n  aran.childs.BreakStatement = function (x) { return [] };\n\n  aran.childs.ContinueStatement = function (x) { return [] };\n\n  aran.childs.WithStatement = function (x) { return [x.object, x.body] };\n\n  aran.childs.SwitchStatement = function (x) {\n    var xs = [x.discriminant];\n    for (var i=0; i<x.cases.length; i++) {\n      if (x.cases[i].test)\n        xs[xs.length] = x.cases[i].test;\n      for (var j=0; j<x.cases[i].consequent.length; j++)\n        xs[xs.length] = x.cases[i].consequent[j];\n    }\n    return xs;\n  };\n\n  aran.childs.ReturnStatement = function (x) { return x.argument ? [x.argument] : [] };\n\n  aran.childs.ThrowStatement = function (x) { return [x.argument] };\n\n  aran.childs.TryStatement = function (x) {\n    var xs = [];\n    for (var i=0; i<x.block.body.length; i++)\n      xs[xs.length] = x.block.body[i];\n    if (x.handler)\n      for (var i=0; i<x.handler.body.body.length; i++)\n        xs[xs.length] = x.handler.body.body[i];\n    if (x.finalizer)\n      for (var i=0; i<x.finalizer.body.length; i++)\n        xs[xs.length] = x.finalizer.body[i];\n    return xs;\n  };\n\n  aran.childs.WhileStatement = function (x) { return [x.test, x.body] };\n\n  aran.childs.DoWhileStatement = function (x) { return [x.body, x.test] };\n\n  aran.childs.ForStatement = function (x) {\n    var xs = [];\n    if (x.init) {\n      if (x.init.type === \"VariableDeclaration\") {\n        for (var i=0; i<x.init.declarations.length; i++)\n          if (x.init.declarations[i].init)\n            xs[xs.length] = x.init.declarations[i].init;\n      } else {\n        xs[xs.length] = x.init;\n      }\n    }\n    if (x.test)\n      xs[xs.length] = x.test;\n    if (x.update)\n      xs[xs.length] = x.update;\n    xs[xs.length] = x.body;\n    return xs;\n  };\n\n  aran.childs.ForInStatement = function (x) {\n    if (x.left.type === \"VariableDeclaration\")\n      var xs = x.left.declarations[0].init ? [x.left.declarations[0].init] : [];\n    else if (x.left.type === \"Identifier\")\n      var xs = [];\n    else if (x.left.type === \"MemberExpression\")\n      var xs = x.left.computed ? [x.left.object, x.left.property] : [x.left.object];\n    else\n      throw new Error(\"Uexpected left type in for-in: \"+x.left.type);\n    xs[xs.length] = x.right;\n    xs[xs.length] = x.body;\n    return xs;\n  };\n\n  aran.childs.DebuggerStatement = function (x) { return [] };\n\n  aran.childs.FunctionDeclaration = function (x) {\n    var xs = [];\n    if (x.body.body.length && !strict(x.body.body[0]))\n      xs[xs.length] = x.body.body[0];\n    for (var i=1; i<x.body.body.length; i++)\n      xs[xs.length] = x.body.body[i];\n    return xs;\n  };\n\n  aran.childs.VariableDeclaration = function (x) {\n    var xs = [];\n    for (var i=0; i<x.declarations.length; i++)\n      if (x.declarations[i].init)\n        xs[xs.length] = x.declarations[i].init;\n    return xs;\n  };\n\n  aran.childs.ThisExpression = function (x) { return [] };\n\n  aran.childs.ArrayExpression = function (x) {\n    var xs = [];\n    for (var i=0; i<x.elements.length; i++)\n      if (x.elements[i])\n        xs[xs.length] = x.elements[i];\n    return xs;\n  };\n\n  aran.childs.ObjectExpression = function (x) {\n    var xs = [];\n    for (var i=0; i<x.properties.length; i++)\n      xs[xs.length] = x.properties[i].value;\n    return xs;\n  };\n\n  aran.childs.FunctionExpression = function (x) {\n    var xs = [];\n    if (x.body.body.length && !strict(x.body.body[0]))\n      xs[xs.length] = x.body.body[0];\n    for (var i=1; i<x.body.body.length; i++)\n      xs[xs.length] = x.body.body[i];\n    return xs;\n  };\n\n  aran.childs.SequenceExpression = function (x) {\n    var xs = [];\n    for (var i=0; i<x.expressions.length; i++)\n      xs[xs.length] = x.expressions[i];\n    return xs;\n  }\n\n  aran.childs.UnaryExpression = function (x) {\n    if (x.operator === \"typeof\" && x.argument.type === \"Identifier\")\n      return [];\n    if (x.operator === \"delete\" && x.argument.type === \"Identifier\")\n      return [];\n    if (x.operator === \"delete\" && x.argument.type === \"MemberExpression\")\n      return x.argument.computed ? [x.argument.object, x.argument.property] : [x.argument.object];\n    return [x.argument];\n  };\n\n  aran.childs.BinaryExpression = function (x) { return [x.left, x.right] };\n\n  aran.childs.AssignmentExpression = function (x) {\n    return (x.left.type === \"Identifier\")\n      ? [x.right]\n      : (x.left.computed ? [x.left.object, x.left.property, x.right] : [x.left.object, x.right]);\n  };\n\n  aran.childs.UpdateExpression = function (x) {\n    return (x.argument.type === \"Identifier\")\n      ? []\n      : (x.argument.computed ? [x.argument.object, x.argument.property] : [x.argument.object]);\n  };\n\n  aran.childs.LogicalExpression = function (x) { return [x.left, x.right] };\n\n  aran.childs.ConditionalExpression = function (x) { return [x.test, x.consequent, x.alternate] };\n\n  aran.childs.NewExpression = function (x) {\n    var xs = [x.callee];\n    for (var i=0; i<x.arguments.length; i++)\n      xs[xs.length] = x.arguments[i];\n    return xs;\n  };\n\n  aran.childs.CallExpression = function (x) {\n    if (x.callee.type === \"Identifier\" && x.callee.name === \"eval\")\n      var xs = [];\n    else if (x.callee.type === \"MemberExpression\")\n      var xs = x.callee.computed ? [x.callee.object, x.callee.property] : [x.callee.object];\n    else\n      var xs = [x.callee];\n    for (var i=0; i<x.arguments.length; i++)\n      xs[xs.length] = x.arguments[i];\n    return xs;\n  };\n\n  aran.childs.MemberExpression = function (x) { return x.computed ? [x.object, x.property] : [x.object] };\n\n  aran.childs.Identifier = function (x) { return [] };\n\n} ());\n\n(function () {\n\n  aran.fetch = function (ast, idx) {\n    if (ast.index === idx)\n      return ast;\n    var childs = aran.childs[ast.type](ast);\n    for (var i=0; i<childs.length; i++)\n      if (idx >= childs[i].index && idx <= childs[i].maxIndex)\n        return aran.fetch(childs[i], idx);\n  };\n\n} ());\n";